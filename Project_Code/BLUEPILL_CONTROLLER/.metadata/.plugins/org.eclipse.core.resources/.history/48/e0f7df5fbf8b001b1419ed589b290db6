/*Library voor het OLED aan te sturen via I2C
 * Jarne Meylemans
 * Aanmaak Datum: 18/3/2021
 *
 * Updates:
 * -------------------------------------------------------------
 *
 */

/* Include Files */
#include "OLED.h"


extern I2C_HandleTypeDef hi2c1;

#define SENDCOMMAND(command)	OLED_I2C_WriteTo(OLED_ADDR, 0x00, (command))
#define SENDDATA(data)  		OLED_I2C_WriteTo(OLED_ADDR, 0x40, (data))

static uint8_t OLED_Buffer[(OLED_WIDTH * OLED_HEIGHT) / 8 ]; /* Aantal bytes dat het scherm groot is */

typedef struct OLED_t {
	uint16_t CurrentX;
	uint16_t CurrentY;
	uint8_t Inverted;
	uint8_t Initialized;
} OLED_t;

static OLED_t OLED;


/* Functions */

/*
 * OLED_Init gaat alles klaarzetten om het scherm te gaan gebruiken
 * 		* checkt of er een device aanwezig is op de bus
 * 		* initialiseerd de OLED zelf via I2C commands
 */
uint8_t OLED_Init(void)
{
	HAL_Delay(10);
	/* Gaan kijken of er een device aanwezig is */
	if(HAL_I2C_IsDeviceReady(&hi2c1, OLED_ADDR, 1, 20000) != HAL_OK)
	{
		// Als er geen device is aangekoppeld gaan we meteen een 0 terugsturen
		return 0;
	}

	HAL_Delay(10);

	/* Initialiseren van de OLED */

	//Fundamental Command Table
	SENDCOMMAND(0xAE); 		// Display afzetten (sleep mode)
	//Addressing Setting Command Table
	SENDCOMMAND(0x20); 		// Set Memory Addressing Mode*
	SENDCOMMAND(0x10);		// 00b => Horizontal Addressing Mode
	SENDCOMMAND(0xB0); 		// Set GDDRAM Page Start Address
	//Hardware Configuration Command Table
	SENDCOMMAND(0xC8); 		// Set COM Output Scan Direction (remapped mode)
	//Addressing Setting Command Table
	SENDCOMMAND(0x00);  	// Set Lower Column start address
	SENDCOMMAND(0x10); 		// Set Higher Column Start Address
	//Hardware Configuration Command Table
	SENDCOMMAND(0x40); 		// Set Display Start Line
	//Fundamental Command Table
	SENDCOMMAND(0x81);		// Set Contrast Control*
	SENDCOMMAND(0xFF); 		// volledig contrast
	//Hardware
	SENDCOMMAND(0xA1); 		// Set Segment Re-Map A1=colomn addr 127
	//Fundamental
	SENDCOMMAND(0xA6);		// Set Normal/Inverse Display A6 = normal
	//Hardware
	SENDCOMMAND(0xA8); 		// Set Multiplex Ratio*
	SENDCOMMAND(0x3F); 		//
	//Fundamental
	SENDCOMMAND(0xA4);		//Entire Display ON , resume to RAM content display
	//Hardware
	SENDCOMMAND(0xD3); 		// Set Display Offset*
	SENDCOMMAND(0x00); 		//not offset
	//Timing & Driving
	SENDCOMMAND(0xD5); 		//*Set Display Clock Divide Ratio/Oscillator Frequency
	SENDCOMMAND(0xF0); 		//
	SENDCOMMAND(0xD9); 		//*Set Pre-charge Period
	SENDCOMMAND(0x22); 		//
	//Hardware
	SENDCOMMAND(0xDA); 		//*Set COM Pins Hardware Configuration
	SENDCOMMAND(0x12);
	//Timing & Driving
	SENDCOMMAND(0xDB); 		//Set VCOMH Deselect Level *
	SENDCOMMAND(0x20);
	SENDCOMMAND(0x8D);		//Set DC-DC enable
	SENDCOMMAND(0x14);
	//Fundamentals
	SENDCOMMAND(0xAF);

	/* bij de commands waar een '*' staat, moet een commando, dat er bij hoort achter worden geplaatst*/

	SENDCOMMAND(0x2E);		//Zet het scrollen af!

	/* Clear Screen */
	OLED_Fill(OLED_BLACK);

	//HAL_Delay(10);
	/* Update Screen */
	OLED_UpdateScreen();

	/*zet standaard waarden*/
	OLED.CurrentX = 0;	/*cursor op 0 gezet */
	OLED.CurrentY = 0;	/*cursor op 0 gezet */

	/* confirm dat de OLED is geinitialiseerd */
	OLED.Initialized = 1;

	/*OK*/
	return 1;
}

void OLED_UpdateScreen(void)
{
	uint8_t m;
	for(m = 0 ;m < 8 ; m++)
	{
		SENDCOMMAND(0xB0 + m); 	//Set Page Start (page 0 tot 7)
		SENDCOMMAND(0x00); 		//Set Lower Column
		SENDCOMMAND(0x10); 		//Set Higher Column

		//grote data schrijven
		/*for(uint8_t i = 0; i < 128 ; i++)	//128
		{
			SENDDATA(OLED_Buffer[(128 * m) + i]);
		}*/

		//OLED_I2C_WriteMultiple(OLED_ADDR, 0x40, &OLED_Buffer[OLED_WIDTH * m], (OLED_WIDTH/2));
		OLED_I2C_WriteMultiple(0x78,0x40,&OLED_Buffer[128 * m], 64);
		//DELAY
		OLED_I2C_WriteMultiple(0x78,0x40,&OLED_Buffer[(128 * m) + 64], 64);
		//DELAY

	}
	/*for(uint8_t m ; m < 8 ; m++)
	{
		OLED_UpdateLayer(m);
	}*/

	//printf("update klaar \r\n");
}

void OLED_UpdateLayer(uint8_t layer)
{
	SENDCOMMAND(0xB0 + layer);
	SENDCOMMAND(0x00);
	SENDCOMMAND(0x10);

	OLED_I2C_WriteMultiple(0x78,0x40,&OLED_Buffer[128 * layer], 128);

	uint8_t p;
	for(p = 0; p < 255 ; p++)
	{
		//delay
	}
}

void OLED_Fill( OLED_COLOR color ){
	/*Vul de buffer met allemaal bits van dezelfde kleur*/
	/*uint8_t kleur = 0x00; // zwarte kleur
	if(color == OLED_BLUE)
	{
		kleur = 0xFF; //blauwe kleur
	}
	for(int i = 0; i < sizeof(OLED_Buffer); i++)
	{
		OLED_Buffer[i] = kleur;
	}*/
	memset(OLED_Buffer,( color == OLED_BLACK ) ? 0x00 : 0xFF, sizeof(OLED_Buffer));
}

void OLED_DrawPixel(uint8_t x, uint8_t y, OLED_COLOR color)
{
	if( y > OLED_HEIGHT || x > OLED_WIDTH )
	{
		//ERROR (niet op het scherm)
		return;
	}

	if(color == OLED_BLUE)
	{
		OLED_Buffer[((OLED_WIDTH / 8) * y) + x] |= 1 << (y % 8);
	}
	else
	{
		OLED_Buffer[((OLED_WIDTH / 8) * y) + x] &= ~(1 << (y % 8));
	}
}

void OLED_Clear(void)
{
	OLED_Fill(OLED_BLACK);
	OLED_UpdateScreen();
}

/* I2C */

void OLED_I2C_WriteMultiple(uint8_t address, uint8_t reg, uint8_t* data,uint16_t count)
{
	uint8_t pdata[256];
	pdata[0] = reg;
	uint8_t i;
	for(i = 0; i < count; i++)
	{
		pdata[i+1] = data[i];
	}
	HAL_I2C_Master_Transmit(&hi2c1, address, pdata, count+1, 10);

}
void OLED_I2C_WriteTo(uint8_t address, uint8_t reg, uint8_t data)
{
	uint8_t pdata[2];
	pdata[0] = 0x00;
	pdata[1] = data;
	HAL_I2C_Master_Transmit(&hi2c1, address, pdata, 2, 10);
}
